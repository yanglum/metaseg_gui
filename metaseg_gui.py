#!/usr/bin/env python
# coding: utf-8

# # metaSeg GUI

# In[46]:


version_no = "13"


# ### change log
# v13: clear borders of image (set to background). Minor tweaks.
#
# v12: automatically load mask when opening image and not in "mass analysis" mode
# 
# v11: add option to draw disk on ecDNA mask to identify ecDNA
# 
# v10: automate identifying doublet ecDNA, allowing for user adjustment
# 
# v9: users can draw rectangle around doublet ecDNA (double minutes), which is kept track of 
# 
# v8: show chrDNA counts. Fixed bug with Continue checkbox. Fixed bug with Reset mask button
# 
# v7: QoL changes: hotkeys (tab to open image, enter to save mask), resize window upon start. Continue checkbox, if checked, now shows images without updated masks. Adjust current image and mask displays. Remove pixel pane (pixel count display)
# 
# v6: add button for marking image as inadequate (write "inadequate" to ec_quantification.csv)
# 
# v5: add true_background mask and add option to see original image (both dapi and stains)
# 
# v4: update ec_quantification csv file with updated counts from findContours when mask is saved
# 
# v3: count ecDNA using ecSeg generated mask and findContours, which updates as mask is updated
# 
# v2: reads the ec_quantification.csv file generated by ecseg and displays # of ec for the opened image
# 
# v1: saves mask with "updated_" prefix and when auto loading masks, looks for "updated_" masks first

# In[1]:


# tf environment, python 3.8.5, skimage 0.18.1
# env = cv2

from tkinter import *
from tkinter import ttk, filedialog
from tkinter import messagebox

from PIL import ImageGrab, Image, ImageTk

import yaml
import os
import pathlib # for making temp directory
import glob # for temp mask files
import datetime # for naming temp mask files
import pickle # for saving DM boxes boundaries

import difflib # for get close matches
                
import numpy as np
from skimage import measure
from skimage import draw
from skimage import io
from skimage.color import gray2rgb

import pandas as pd
import cv2


# In[14]:


def filename_counter(counter):
    if counter < 10:
        fname = "000"+str(counter)
    elif counter < 100:
        fname = "00"+str(counter)
    elif counter < 1000:
        fname = "0"+str(counter)
    else:
        fname = str(counter)
    return fname


# In[15]:


def update_temp(*args): # this is for drawing lines for polygons (temporary)
    temp_overlay = image_dict['image_overlay'].copy()
    temp_overlay[mask_dict['temp_mask']] = [0,0,0]
    image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(temp_overlay))
    canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")

# funtion to be called when "Polygon select" button is clicked
def select_polygon(*args):    
    canvas.bind("<ButtonPress-1>", savecoords)
    canvas.bind("<Double-Button-1>", mask_set) # double clicking ends coords collection and calculates

def savecoords(event):
    
    event2canvas = lambda e, c: (c.canvasx(e.x), c.canvasy(e.y)) # converts event (window) coordinates to image coordinates
    cx, cy = event2canvas(event, canvas)
    
    # prevent out of bounds event
    if cx < 0:
        cx = 0
    if cx >= image_dict['image0'].shape[1]:
        cx = image_dict['image0'].shape[1]-1
    if cy < 0:
        cy = 0
    if cy >= image_dict['image0'].shape[0]:
        cy = image_dict['image0'].shape[0]-1
        
    xcoor.append(int(cx))
    ycoor.append(int(cy))

    if len(xcoor)>1:
        rr, cc = draw.line(ycoor[-2], xcoor[-2], ycoor[-1], xcoor[-1])
        mask_dict['temp_mask'][rr, cc] = True
        update_temp()

def mask_set(event): 
    event2canvas = lambda e, c: (c.canvasx(e.x), c.canvasy(e.y)) # converts event (window) coordinates to image coordinates
    cx, cy = event2canvas(event, canvas)
    xcoor.append(cx)
    ycoor.append(cy)
    r = np.array(ycoor)
    c = np.array(xcoor)
    rr, cc = draw.polygon(r, c)
    
    # reset
    xcoor.clear()
    ycoor.clear()
    mask_dict['temp_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
    
    flip_masks(switches['flip_from'], switches['flip_to'], rr, cc)

def flip_masks(flip_from, flip_to, rr, cc):
    '''
    flip masks from/to background, fat, bone, cartilage, blood, cells
    flip_from is a list of strings
    flip_to is a string
    '''
    for i in flip_from:
        if i == 0:
            mask_dict['back_mask'][rr,cc] = False
        elif i == 1:
            mask_dict['nuclei_mask'][rr,cc] = False
        elif i == 2:
            mask_dict['chromo_mask'][rr,cc] = False
        elif i == 3:
            mask_dict['ecdna_mask'][rr,cc] = False
        elif i == 4:
            mask_dict['trueba_mask'][rr,cc] = False

    temp_filter = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), True)
    temp_filter[mask_dict['back_mask']] = False
    temp_filter[mask_dict['nuclei_mask']] = False
    temp_filter[mask_dict['chromo_mask']] = False
    temp_filter[mask_dict['ecdna_mask']] = False
    temp_filter[mask_dict['trueba_mask']] = False
    
    for i in flip_to:
        if i == 0:
            mask_dict['back_mask'][temp_filter] = True
        elif i == 1:
            mask_dict['nuclei_mask'][temp_filter] = True
        elif i == 2:
            mask_dict['chromo_mask'][temp_filter] = True
        elif i == 3:
            mask_dict['ecdna_mask'][temp_filter] = True
        elif i == 4:
            mask_dict['trueba_mask'][temp_filter] = True

    update_image(update_pixels=True, save_temp=True)
    
# function to be called when "reset polygon" button is clicked
def reset_polygon(*args):
    xcoor.clear()
    ycoor.clear()
    mask_dict['temp_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
    update_temp()


# In[ ]:


# v9 IDENTIFY DOUBLETS (DMs)

# funtion to be called when draw box button is clicked
def mark_dms(*args):    
    canvas.bind("<ButtonPress-1>", draw_rectangle)
    canvas.bind("<B1-Motion>", set_rectangle)
    canvas.bind("<ButtonRelease-1>", save_rectangle) # double clicking ends coords collection and calculates

def draw_rectangle(event):
    event2canvas = lambda e, c: (c.canvasx(e.x), c.canvasy(e.y)) # converts event (window) coordinates to image coordinates
    cx, cy = event2canvas(event, canvas)
    
    # prevent out of bounds event
    if cx < 0:
        cx = 0
    if cx >= image_dict['image0'].shape[1]:
        cx = image_dict['image0'].shape[1]-1
    if cy < 0:
        cy = 0
    if cy >= image_dict['image0'].shape[0]:
        cy = image_dict['image0'].shape[0]-1
    
    double_minutes['temp'] = (int(cy), int(cx))

def set_rectangle(event):
    if np.random.randint(2) == 1:
        mask_dict['temp_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)

        event2canvas = lambda e, c: (c.canvasx(e.x), c.canvasy(e.y)) # converts event (window) coordinates to image coordinates
        cx, cy = event2canvas(event, canvas)

        rr, cc = draw.rectangle_perimeter((cy, cx), double_minutes['temp'])
        mask_dict['temp_mask'][rr, cc] = True
        update_temp()

def save_rectangle(event):
    event2canvas = lambda e, c: (c.canvasx(e.x), c.canvasy(e.y)) # converts event (window) coordinates to image coordinates
    cx, cy = event2canvas(event, canvas)
    
    rr, cc = draw.rectangle_perimeter((cy, cx), double_minutes['temp'])
    
    double_minutes['rectangles'].append([rr, cc])
    
    mask_dict['temp_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
    
    dm_count.set(len(double_minutes['rectangles']))
    update_image(update_pixels=False, save_temp=False)
    
    canvas.unbind("<B1-Motion>")
    canvas.unbind("<ButtonRelease-1>")
    
def undo_rectangle(*args):
    double_minutes['rectangles'].clear()
    dm_count.set(len(double_minutes['rectangles']))
    update_image(update_pixels=False, save_temp=False)

# v10 use find contours to look for oblong ecDNA suggestive of doublets
def auto_dm(*args):
    cnts = cv2.findContours(mask_dict['ecdna_mask'].astype(np.uint8), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)[-2]
    for cnt in cnts:
        try:
            (x, y), (d1, d2), angle = cv2.fitEllipse(cnt)
        except:
            continue
        MA = max(d1, d2)
        ma = min(d1, d2)
        eccentricity = (1 - ma/MA)**0.5
        if eccentricity > 0.5: # v13
            xx,yy,w,h = cv2.boundingRect(cnt)
            rr, cc = draw.rectangle_perimeter((yy, xx), (yy+h, xx+w))
            if set(map(tuple,[rr, cc])) not in [set(map(tuple,x)) for x in double_minutes['rectangles']]:
                double_minutes['rectangles'].append([rr, cc])

    dm_count.set(len(double_minutes['rectangles']))
    update_image(update_pixels=False, save_temp=False)
    
def undraw_rectangle(*args):
    canvas.bind("<ButtonPress-1>", undraw_box)

def undraw_box(event):
    event2canvas = lambda e, c: (c.canvasx(e.x), c.canvasy(e.y)) # converts event (window) coordinates to image coordinates
    cx, cy = event2canvas(event, canvas)
    
    point = [cy, cx] # r, c

    for rect in double_minutes['rectangles']:
        vertices = np.array([(max(rect[0]), min(rect[1])), # ul
                    (max(rect[0]), max(rect[1])), # ur
                    (min(rect[0]), max(rect[1])), # lr
                    (min(rect[0]), min(rect[1]))]) # ll

        if measure.points_in_poly([point], vertices)[0]:
            double_minutes['rectangles'].remove(rect)
            break
            
    dm_count.set(len(double_minutes['rectangles']))
    update_image(update_pixels=False, save_temp=False)


# In[ ]:


def dot_ec(*args):  
    canvas.bind("<ButtonPress-1>", draw_dot)

def draw_dot(event):
    event2canvas = lambda e, c: (c.canvasx(e.x), c.canvasy(e.y)) # converts event (window) coordinates to image coordinates
    cx, cy = event2canvas(event, canvas)
    rr, cc = draw.disk((cy, cx), dot_radius.get())
    
    mask_dict['back_mask'][rr,cc] = False
    mask_dict['nuclei_mask'][rr,cc] = False
    mask_dict['chromo_mask'][rr,cc] = False
    mask_dict['ecdna_mask'][rr, cc] = True
    mask_dict['trueba_mask'][rr,cc] = False

    update_image(update_pixels=True, save_temp=True)


# In[16]:


# this is run at the beginning when load_mask is called
def update_image(update_pixels=False, save_temp=False):
    if 'display_masks' not in switches:
        image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(image_dict['image0']))
        canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")
        
    else:
        image_dict['image_overlay'] = image_dict['image0'].copy()
        
        for i in switches['display_masks']:
            if i == 0:
                image_dict['image_overlay'][mask_dict['back_mask']] = [56, 108, 176]
            elif i == 1:
                image_dict['image_overlay'][mask_dict['nuclei_mask']] = [255, 255, 153]
            elif i == 2:
                image_dict['image_overlay'][mask_dict['chromo_mask']] = [127, 201, 127]
            elif i == 3:
                image_dict['image_overlay'][mask_dict['ecdna_mask']] = [240, 2, 127]
            elif i == 4:
                mask_dict['dm_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
                for rect in double_minutes['rectangles']:
                    mask_dict['dm_mask'][tuple(rect)] = True
                image_dict['image_overlay'][mask_dict['dm_mask']] = [0, 0, 0]
            elif i == 5:
                image_dict['image_overlay'][mask_dict['trueba_mask']] = [0, 0, 0]            

        image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(image_dict['image_overlay']))
        canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")
    
    if update_pixels==True: # this should be called when masks are actually manipulated 
        # Set pixels
        back_pixels.set(mask_dict['back_mask'].sum())
        nuclei_pixels.set(mask_dict['nuclei_mask'].sum())
        chromo_pixels.set(mask_dict['chromo_mask'].sum())
        ecdna_pixels.set(mask_dict['ecdna_mask'].sum())
        trueba_pixels.set(mask_dict['trueba_mask'].sum())

        unmasked_pixels.set(image_pixels.get() - (back_pixels.get()+
                                                  nuclei_pixels.get()+
                                                  chromo_pixels.get()+
                                                  ecdna_pixels.get()+
                                                  trueba_pixels.get()))
        
        # v3 update ecDNA counts using findContours
        cnts = cv2.findContours(mask_dict['ecdna_mask'].astype(np.uint8), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)[-2]
        updated_eccount.set(len(cnts))            
                
        # v8 update echrDNA counts using findContours
        cnts = cv2.findContours(mask_dict['chromo_mask'].astype(np.uint8), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)[-2]
        updated_chrcount.set(len(cnts))
    
    if save_temp==True: # called when masks are created, loaded, or manipulated
        pathlib.Path('./temp').mkdir(parents=True, exist_ok=True)

        temp_filter = np.zeros((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), dtype=np.uint8)
        temp_filter = gray2rgb(temp_filter)
        temp_filter[mask_dict['back_mask']] = [56, 108, 176]
        temp_filter[mask_dict['nuclei_mask']] = [255, 255, 153]
        temp_filter[mask_dict['chromo_mask']] = [127, 201, 127]
        temp_filter[mask_dict['ecdna_mask']] = [240, 2, 127]
        temp_filter[mask_dict['trueba_mask']] = [0, 0, 0]

        io.imsave('./temp/temp_mask'+datetime.datetime.now().strftime('%Y%m%d%H%M%S')+'.png',
                  temp_filter, check_contrast=False)
    
def undo_manip(*args):
    try:
        latest_temp = get_latest_file('./temp/temp_mask*')
        os.remove(latest_temp)
        latest_temp = get_latest_file('./temp/temp_mask*')
        temp_filter = io.imread(latest_temp)
        divide_masks(temp_filter)
        update_image(update_pixels=True)
    except:
        messagebox.showinfo(message='Nothing to undo')

def get_latest_file(directory):
    temp_mask_list = glob.glob(directory)
    latest_temp = max(temp_mask_list, key=os.path.getctime)
    return latest_temp


# In[17]:


def divide_masks(mask):
    reset(reset_masks=True)
    mask_dict['back_mask'][np.where(np.all(mask==[56, 108, 176], axis=-1))] = True
    mask_dict['nuclei_mask'][np.where(np.all(mask==[255, 255, 153], axis=-1))] = True
    mask_dict['chromo_mask'][np.where(np.all(mask==[127, 201, 127], axis=-1))] = True
    mask_dict['ecdna_mask'][np.where(np.all(mask==[240, 2, 127], axis=-1))] = True
    mask_dict['trueba_mask'][np.where(np.all(mask==[0, 0, 0], axis=-1))] = True
    
def reset(reset_image=False, reset_masks=False, reset_pixels=False, reset_dm=False): # does not reset ecseg mask
    if reset_image==True:
        # reset image
        image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(image_dict['image0']))
        canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")
        image_dict['image_overlay'] = image_dict['image0'].copy()
    
    if reset_masks==True:
        # reset masks    
        mask_dict['back_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
        mask_dict['nuclei_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
        mask_dict['chromo_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
        mask_dict['ecdna_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
        mask_dict['trueba_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
        mask_dict['temp_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
        mask_dict['dm_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
    
    if reset_pixels==True:
        # reset pixels
        back_pixels.set(0)
        nuclei_pixels.set(0)
        chromo_pixels.set(0)
        ecdna_pixels.set(0)

        unmasked_pixels.set(image_pixels.get())
    
    if reset_dm==True:
        double_minutes['rectangles'].clear()
        dm_count.set(len(double_minutes['rectangles']))
    
def show_original(*args):  
    temp_overlay = image_dict['image0'].copy()
            
    temp_overlay[mask_dict['temp_mask']] = [0,0,0]
    image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(temp_overlay))
    canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")

def show_analyzed(*args):
    image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(image_dict['image_overlay']))
    canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")
    
def show_color_image(*args):
    image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(image_dict['color_image']))
    canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")


# In[61]:


def populate_image_files(*args):
    all_files.clear()
    populated.set(False) # v13
    for file in os.listdir(image_path.get()):
        if file.endswith(".PNG") or file.endswith(".png") or file.endswith(".TIF") or file.endswith(".tif"):
            if continue_state.get() == 1:
                if 'updated_'+file[:-4]+'.png' not in os.listdir(mask_path.get()): #v7
                    all_files.append(file)
            elif continue_state.get() == 0:
                all_files.append(file)

def clear_temp_folder(*args):
    if pathlib.Path('temp').is_dir():
        files = glob.glob('temp\*')
        for f in files:
            try:
                os.remove(f)
            except:
                pass
    
def open_file(*args): 
    #try:
        if mass_state.get() == 0:
            File = filedialog.askopenfilename(parent=root, initialdir=image_path.get(), # v13
                                    title='Select image file to open')#, filetypes=[("image", ".png", ".tif")])
            #print("opening %s" % File)
        elif mass_state.get() == 1:
            if populated.get(): # v13
                populate_image_files()
            File = os.path.join(image_path.get(), all_files[file_number.get()])
            file_number.set(file_number.get()+1)
            if file_number.get() == len(all_files):
                messagebox.showinfo(message='This will be the last image') #v13
        
        clear_temp_folder()
        imgfile.set(File.split('/')[-1])
        image_dict['image0'] = io.imread(File) # must be .png or .tif
        
        if os.path.isdir(os.path.join(inpath, 'original')): #v7
            color_image = difflib.get_close_matches(imgfile.get(), os.listdir(inpath+'/original'), n=1, cutoff=0)[0]
            image_dict['color_image'] = io.imread(inpath+'/original/'+color_image)
        else: #v7
            color_image = difflib.get_close_matches(imgfile.get(), os.listdir(inpath), n=1, cutoff=0)[0]
            image_dict['color_image'] = io.imread(inpath+'/'+color_image)
        
        if len(np.shape(image_dict['image0'])) == 3:
            image_dict['image0'] = image_dict['image0'][:, :, :3] # make sure the image only has 3 color channels (no alpha)
        else:
            image_dict['image0'] = gray2rgb(image_dict['image0'])
        image_pixels.set(int(image_dict['image0'].size/3))
    
        reset(reset_image=True, reset_masks=True, reset_pixels=True, reset_dm=True)
        mask_dict.pop('ecseg_mask', None)
        
        canvas.config(scrollregion=canvas.bbox(ALL), width=image_dict['image1'].width(), height=image_dict['image1'].height()) # initiates window with adjusted size to image_dict['image1']
        
        load_masks()
    #except:
    #    print('open_file error')


# In[62]:


def save(*args):
    if unmasked_pixels.get()!=0:
        proceed = messagebox.askyesno(message='There are unmasked pixels! Proceed?',
                           icon='question', title='Save mask')
        if proceed == True:
            save_masks()
            messagebox.showinfo('Mask saved as:', maskfile.get())
    elif unmasked_pixels.get()<0:
        proceed = messagebox.askyesno(message='There are double-masked pixels! Proceed?',
                           icon='question', title='Save mask')
        if proceed == True:
            save_masks()
            messagebox.showinfo('Mask saved as:', maskfile.get())
    else:
        save_masks()
        messagebox.showinfo('Mask saved as:', maskfile.get())

def save_masks(*args): # called on by function save() (defined in tkinter)
    temp_filter = np.zeros((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), dtype=np.uint8)
    temp_filter = gray2rgb(temp_filter)
    
    temp_filter[mask_dict['back_mask']] = [56, 108, 176]
    temp_filter[mask_dict['nuclei_mask']] = [255, 255, 153]
    temp_filter[mask_dict['chromo_mask']] = [127, 201, 127]
    temp_filter[mask_dict['ecdna_mask']] = [240, 2, 127]
    temp_filter[mask_dict['trueba_mask']] = [0, 0, 0]

    # background = [56, 108, 176]
    # nuclei = [255, 255, 153]
    # chromosome = [127, 201, 127]
    # ecdna = [240, 2, 127]

    try:
        #if mass_state.get() == 0:  v12
        #    File = filedialog.asksaveasfilename(parent=root, initialdir=inpath,
        #                                        title='Save as', filetypes=[("image", ".png")])
        #    maskfile.set(File.split('/')[-1])
        #    io.imsave(maskfile.get(), temp_filter, check_contrast=False)
        #elif mass_state.get() == 1:
            maskfile.set('updated_' + imgfile.get()[:-4] + '.png')
            io.imsave(mask_path.get() + maskfile.get(), temp_filter, check_contrast=False)
    except:
        print('save_masks error')
    
    # v9 save dm box coordinates
    try:
        with open(mask_path.get()+imgfile.get()[:-4]+'dms', "wb") as fp:   #Pickling
            pickle.dump(double_minutes['rectangles'], fp)
    except:
        pass
    
    # v4 update and save ec_quantification.csv file
    image_dict['ec_counts'].loc[image_dict['ec_counts']['image name']==imgfile.get(), 'updated #']=updated_eccount.get()   
    image_dict['ec_counts'].loc[image_dict['ec_counts']['image name']==imgfile.get(), 'doublet #']=dm_count.get()
    image_dict['ec_counts'].to_csv(inpath+'/ec_quantification.csv', index=False)    
    
    # clear temp directory
    clear_temp_folder()

# v6
def mark_inadequate(*args):
    image_dict['ec_counts'].loc[image_dict['ec_counts']['image name']==imgfile.get(), 'updated #']='inadequate'   
    image_dict['ec_counts'].to_csv(inpath+'/ec_quantification.csv', index=False)  
    
def load_masks(*args):
    if 'image0' not in image_dict:
        messagebox.showinfo(message='Open an image file first')
        return
    try:
        #if mass_state.get() == 0: v12
        #    File = filedialog.askopenfilename(parent=root, initialdir=inpath,
        #                                title='Select mask (labels) file to open', filetypes=[("image", ".png")])
        #    maskfile.set(File.split('/')[-1])
        #    mask_dict['ecseg_mask'] = io.imread(File)
        #    mask_dict['ecseg_mask'] = mask_dict['ecseg_mask'][:,:,:3]

        #elif mass_state.get() == 1:
            updatedFile = mask_path.get() + 'updated_' + imgfile.get()[:-4] + '.png'
            File = mask_path.get() + imgfile.get()[:-4] + '.png'
            if os.path.exists(updatedFile):
                maskfile.set(updatedFile.split('/')[-1])
                mask_dict['ecseg_mask'] = io.imread(updatedFile)
            else:
                maskfile.set(File.split('/')[-1])
                mask_dict['ecseg_mask'] = io.imread(File)
            mask_dict['ecseg_mask'] = mask_dict['ecseg_mask'][:,:,:3]
    except:
        print('load_masks error')
    
    # v9 load dm box coordinates
    try:
        with open(mask_path.get()+imgfile.get()[:-4]+'dms', "rb") as fp:   # Unpickling
            double_minutes['rectangles'] = pickle.load(fp)
        dm_count.set(len(double_minutes['rectangles']))
    except:
        pass
    
    divide_masks(mask_dict['ecseg_mask'])
	
	# v13 turn border into background
    rr = []
    cc = []
    for i in range(5):
	    r, c = draw.rectangle_perimeter((i+1,i+1), end=(image_dict['image0'].shape[0]-(i+2), image_dict['image0'].shape[1]-(i+2)))
	    rr.append(r.tolist())
	    cc.append(c.tolist())
    flip_masks([0,1,2,3,4], [0], np.concatenate(rr), np.concatenate(cc))

    update_image(update_pixels=True, save_temp=True)
      
    # v2 load ecSeg counts
    image_dict['ec_counts'] = pd.read_csv(inpath+'/ec_quantification.csv')
    ecseg_count.set(int(image_dict['ec_counts'].loc[image_dict['ec_counts']['image name']==imgfile.get(), '# of ec']))


# In[63]:


###### intialize ######
config = open("config.yaml")
var = yaml.load(config, Loader=yaml.FullLoader)['metaseg']
inpath = var['inpath']

LABELS = ['background','nuclei', 'chromosome', 'ecdna', 'doublets', 'true background']

# background = [56, 108, 176]
# nuclei = [255, 255, 153]
# chromosome = [127, 201, 127]
# ecdna = [240, 2, 127]

all_files = []

# for polygon mask flip tool
ycoor = []
xcoor = []

switches = {}
# flip_from
# flip_to
# display_masks

image_dict = {}
# image0 is the original, never manipulate once open
# image_overlay is manipulated with overlaid masks instead
# image1

mask_dict = {}
# ecseg_mask is the original, never manipulate once created or loaded. Resets only when new image is opened
# individual masks are edited with tools: back_mask, nuclei_mask, chromo_mask, ecdna_mask, blood_mask, marrow_mask, temp_mask

double_minutes = {}
double_minutes['rectangles'] = []

# v4 duplicate # of ec column in ec_quantification.csv
ecseg_df = pd.read_csv(inpath+'/ec_quantification.csv')
if 'updated #' not in ecseg_df.columns:
    ecseg_df['updated #'] = ecseg_df['# of ec']
if 'doublet #' not in ecseg_df.columns: # v9
    ecseg_df['doublet #'] = [0]*len(ecseg_df['# of ec'])
ecseg_df.to_csv(inpath+'/ec_quantification.csv', index=False)
###### initialize ######


# In[73]:


# Tkinter GUI
root = Tk()
root.title('metaSeg GUI')
#root.geometry('280x400-1+3')

mainframe = ttk.Panedwindow(root, orient=HORIZONTAL) # canvas is preventing horizontal placement of canvas child
mainframe.pack(fill=BOTH, expand=1)
mainframe.grid_columnconfigure(0, weight=1) # expand frame to fill extra space if window is resized
mainframe.grid_rowconfigure(0, weight=1)

# image frame
image_frame = ttk.Frame(mainframe) # doesn't matter what this widget is (Label, Frame, etc) because canvas takes over
image_frame.pack(fill=BOTH, expand=1)
image_frame.grid_columnconfigure(0, weight=1) # expand frame to fill extra space if window is resized
image_frame.grid_rowconfigure(0, weight=1)
mainframe.add(image_frame)

xscroll = Scrollbar(image_frame, orient=HORIZONTAL)
xscroll.grid(row=1, column=0, sticky=E+W)
yscroll = Scrollbar(image_frame)
yscroll.grid(row=0, column=1, sticky=N+S)
canvas = Canvas(image_frame, bd=0, xscrollcommand=xscroll.set, yscrollcommand=yscroll.set)
canvas.grid(row=0, column=0, sticky=N+S+E+W)
xscroll.config(command=canvas.xview)
yscroll.config(command=canvas.yview)
image_frame.pack(fill=BOTH,expand=1)

# paned windows for widgets (inside mainframe)
paned = ttk.Panedwindow(mainframe, orient=HORIZONTAL)
paned.pack(fill=BOTH, expand=1)
mainframe.add(paned)

subpaned1 = ttk.Panedwindow(paned, orient=VERTICAL)
paned.add(subpaned1)
acq_pane = ttk.Labelframe(subpaned1, text='Image acquisition')
subpaned1.add(acq_pane)
curr_pane = ttk.Labelframe(subpaned1, text='Current files')
subpaned1.add(curr_pane)

subpaned3 = ttk.Panedwindow(paned, orient=VERTICAL)
paned.add(subpaned3)
masks_pane = ttk.Labelframe(subpaned3, text='Show masks')
subpaned3.add(masks_pane)

subpaned4 = ttk.Panedwindow(paned, orient=VERTICAL)
paned.add(subpaned4)
toolbar_pane = ttk.Labelframe(subpaned4, text='Flip masks')
subpaned4.add(toolbar_pane)

# v9
subpaned5 = ttk.Panedwindow(paned, orient=VERTICAL)
paned.add(subpaned5)
dot_pane = ttk.Labelframe(subpaned5, text='Dot ecDNA') # v11
subpaned5.add(dot_pane) # v2
dm_pane = ttk.Labelframe(subpaned5, text='Identify doublets')
subpaned5.add(dm_pane) # v2
count_pane = ttk.Labelframe(subpaned5, text='Counts') # v3 # v9
subpaned5.add(count_pane) # v3 # v7

subpaned6 = ttk.Panedwindow(paned, orient=VERTICAL)
paned.add(subpaned6)
about_pane = ttk.Labelframe(subpaned6, text='Info')
subpaned6.add(about_pane)

#################### IMAGE ACQUISITION ######################
# Open image
ttk.Button(acq_pane, text='Open image', command=open_file).grid(column=1, row=1, sticky=(W,E))

# Save masks button
maskfile = StringVar()
ttk.Button(acq_pane, text='Save mask', command=save).grid(column=2, row=1, sticky=(W,E))

# Load masks button
#ttk.Button(acq_pane, text='Load mask', command=load_masks).grid(column=2, row=2, sticky=(W,E))

# Mass analysis checkbox
file_number = IntVar()
file_number.set(0)
populated = BooleanVar() # v13
populated.set(True) # v13
mass_state = IntVar(value=1)
ttk.Checkbutton(acq_pane, text='Mass analysis', variable=mass_state).grid(column=1, row=3, sticky=(W,E))
# if checked, presumes there is an images subdir and masks subdir. Open will open images in order from images/, save will save masks to masks/

# Continue from where left off checkbox
continue_state = IntVar()
ttk.Checkbutton(acq_pane, text='Continue', command=populate_image_files, 
                variable=continue_state).grid(column=2, row=3, sticky=(W,E))

# Image directory
image_path = StringVar()
ttk.Label(acq_pane, text='Image directory:').grid(column=1, row=4, sticky=(W,E))
id_entry = ttk.Entry(acq_pane, textvariable=image_path, width=15)
id_entry.grid(column=2, row=4, sticky=W)
id_entry.insert(0, inpath+'/dapi/')

# Mask directory
mask_path = StringVar()
ttk.Label(acq_pane, text='Mask directory:').grid(column=1, row=5, sticky=(W,E))
md_entry = ttk.Entry(acq_pane, textvariable=mask_path, width=15)
md_entry.grid(column=2, row=5, sticky=W)
md_entry.insert(0, inpath+'/labels/')

# v9
imgfile = StringVar()
ttk.Label(curr_pane, text='Image:').grid(column=1, row=6, sticky=(W,E))
ci_entry = ttk.Entry(curr_pane, textvariable=imgfile, width=24)
ci_entry.grid(column=2, row=6, sticky=W)
ci_entry.config(state= "disabled")
#ttk.Label(curr_pane, textvariable=imgfile).grid(column=2, row=6, sticky=(W,E))

ttk.Label(curr_pane, text='Mask:').grid(column=1, row=7, sticky=(W,E))
cm_entry = ttk.Entry(curr_pane, textvariable=maskfile, width=24)
cm_entry.grid(column=2, row=7, sticky=W)
cm_entry.config(state= "disabled")
#ttk.Label(curr_pane, textvariable=maskfile).grid(column=2, row=7, sticky=(W,E))
#################### IMAGE ACQUISITION ######################

######################### REPORT ######################### 
# Show masks
def update_display(*args):
    switches['display_masks'] = show_masks.curselection()
    update_image()
choicesvar = StringVar(value=LABELS)
show_masks = Listbox(masks_pane, listvariable=choicesvar, activestyle='none',
                     selectmode='extended', exportselection=0, width=15, height=len(LABELS))
show_masks.select_set(3)
show_masks.grid(column=1, row=1, sticky=(W,E))
show_masks.bind("<<ListboxSelect>>", update_display)

def hide_all(*args):
    show_masks.selection_clear(0, END)
    switches.pop('display_masks', None) # really should be an empty tuple, but doesn't matter
    update_image()
ttk.Button(masks_pane, text='Hide all', command=hide_all).grid(column=1, row=2, sticky=(W,E))

# v6
ttk.Button(masks_pane, text='Mark inadequate', command=mark_inadequate).grid(column=1, row=3, sticky=(W,E))
######################### REPORT #########################

#################### TOOLBAR ######################
def update_flip(*args):
    switches['flip_from'] = from_.curselection()
    switches['flip_to'] = to_.curselection()
flip_labels = LABELS[0:LABELS.index('doublets')]+LABELS[LABELS.index('doublets')+1:]
choicesvar = StringVar(value=flip_labels)

ttk.Label(toolbar_pane, text='Flip from:').grid(column=1, row=1, sticky=(W,E))
from_ = Listbox(toolbar_pane, listvariable=choicesvar, selectmode='extended', activestyle='none',
                exportselection=0, width=15, height=len(flip_labels))
from_.grid(column=1, row=2, sticky=(W,E))
from_.bind("<<ListboxSelect>>", update_flip)

ttk.Label(toolbar_pane, text='Flip to:').grid(column=2, row=1, sticky=(W,E))
to_ = Listbox(toolbar_pane, listvariable=choicesvar, selectmode='browse', activestyle='none',
              exportselection=0, width=15, height=len(flip_labels))
to_.grid(column=2, row=2, sticky=(W,E))
to_.bind("<<ListboxSelect>>", update_flip)

ttk.Button(toolbar_pane, text='Polygon flip', command=select_polygon).grid(column=1, row=3, sticky=(W,E))
ttk.Button(toolbar_pane, text='Reset polygon', command=reset_polygon).grid(column=2, row=3, sticky=(W,E))
ttk.Button(toolbar_pane, text='Undo', command=undo_manip).grid(column=1, row=4, sticky=(W,E))

def reset_mask_button(*args):
    divide_masks(mask_dict['ecseg_mask'])
    update_image(update_pixels=True, save_temp=True)
    
ttk.Button(toolbar_pane, text='Reset mask', command=reset_mask_button).grid(column=2, row=4, sticky=(W,E))
#################### TOOLBAR ######################

############################ PIXELS ###########################
image_pixels = IntVar()
#ttk.Label(pixel_pane, text='Image:').grid(column=1, row=1, sticky=E)
#ttk.Label(pixel_pane, textvariable=image_pixels).grid(column=2, row=1, sticky=W)

ecdna_pixels = IntVar()
#ttk.Label(pixel_pane, text='ecDNA:').grid(column=1, row=2, sticky=E)
#ttk.Label(pixel_pane, textvariable=ecdna_pixels).grid(column=2, row=2, sticky=W)

chromo_pixels = IntVar()
#ttk.Label(pixel_pane, text='Chromosome:').grid(column=1, row=3, sticky=E)
#ttk.Label(pixel_pane, textvariable=chromo_pixels).grid(column=2, row=3, sticky=W)

nuclei_pixels = IntVar()
#ttk.Label(pixel_pane, text='Nuclei:').grid(column=1, row=4, sticky=E)
#ttk.Label(pixel_pane, textvariable=nuclei_pixels).grid(column=2, row=4, sticky=W)

back_pixels = IntVar()
#ttk.Label(pixel_pane, text='Background:').grid(column=1, row=5, sticky=E)
#ttk.Label(pixel_pane, textvariable=back_pixels).grid(column=2, row=5, sticky=W)

trueba_pixels = IntVar()
#ttk.Label(pixel_pane, text='True background:').grid(column=1, row=6, sticky=E)
#ttk.Label(pixel_pane, textvariable=trueba_pixels).grid(column=2, row=6, sticky=W)

unmasked_pixels = IntVar()
#ttk.Label(pixel_pane, text='Unmasked:').grid(column=1, row=6, sticky=E)
#ttk.Label(pixel_pane, textvariable=unmasked_pixels).grid(column=2, row=6, sticky=W)

# v9 v10
ttk.Button(dm_pane, text='Auto ID doublets', command=auto_dm).grid(column=1, row=1, sticky=(W,E))
ttk.Button(dm_pane, text='Undraw box', command=undraw_rectangle).grid(column=1, row=2, sticky=(W,E))
ttk.Button(dm_pane, text='Draw box', command=mark_dms).grid(column=2, row=1, sticky=(W,E))
ttk.Button(dm_pane, text='Delete all boxes', command=undo_rectangle).grid(column=2, row=2, sticky=(W,E))

# v11
dot_radius = IntVar()
dot_radius.set(4)
ttk.Button(dot_pane, text='Draw dot', command=dot_ec).grid(column=1, row=1, sticky=(W,E))
ttk.Label(dot_pane, text='Dot radius:').grid(column=2, row=1, sticky=E)
ttk.Spinbox(dot_pane, from_=1, to=10, increment=1, width=3, textvariable=dot_radius).grid(column=3, row=1, sticky=E)

# v2
ecseg_count = IntVar()
ttk.Label(count_pane, text='ecDNA original:').grid(column=1, row=1, sticky=E)
ttk.Label(count_pane, textvariable=ecseg_count).grid(column=2, row=1, sticky=W)

# v3
updated_eccount = IntVar()
ttk.Label(count_pane, text='ecDNA updated:').grid(column=1, row=2, sticky=E)
ttk.Label(count_pane, textvariable=updated_eccount).grid(column=2, row=2, sticky=W)

ttk.Label(count_pane, text='   ').grid(column=3, row=1, sticky=E)
ttk.Label(count_pane, text='   ').grid(column=3, row=2, sticky=E)

# v9
dm_count = IntVar()
ttk.Label(count_pane, text='Doublets:').grid(column=4, row=1, sticky=E)
ttk.Label(count_pane, textvariable=dm_count).grid(column=5, row=1, sticky=W)

# v8
updated_chrcount = IntVar()
ttk.Label(count_pane, text='chrDNA:').grid(column=4, row=2, sticky=E)
ttk.Label(count_pane, textvariable=updated_chrcount).grid(column=5, row=2, sticky=W)
############################ PIXELS ###########################

#################### INFORMATION ######################
# About button
def about():
    messagebox.showinfo(
        message='GUI for evaluating and editing labels generated by ecSeg. Version '+version_no
    )
ttk.Button(about_pane, text='About', command=about).grid(column=1, row=1, sticky=(W,E))

def hot_keys(*args):
    new_window = Toplevel(root)
    new_window.title('Hot Keys')
    new_window.resizable(False, False)
    topframe = ttk.Panedwindow(new_window, orient=VERTICAL)
    topframe.pack(fill=BOTH, expand=1)
    topframe.grid_columnconfigure(0, weight=1) # expand frame to fill extra space if window is resized
    topframe.grid_rowconfigure(0, weight=1)
    
    report = Text(topframe, width=50, height=6, background='white')
    report.grid(column=1, row=1, sticky=(W,E))
    report.insert('1.0',
'''tab: open image
hold left shift: display dapi image
hold control: display original image
right shift: save mask
left alt: draw box
right alt: polygon flip''')
    report.config(state=DISABLED)
ttk.Button(about_pane, text='Hot keys', command=hot_keys).grid(column=1, row=2, sticky=(W,E))

def helping():
    new_window = Toplevel(root)
    new_window.title('Help')
    new_window.resizable(False, False)
    topframe = ttk.Panedwindow(new_window, orient=VERTICAL)
    topframe.pack(fill=BOTH, expand=1)
    topframe.grid_columnconfigure(0, weight=1) # expand frame to fill extra space if window is resized
    topframe.grid_rowconfigure(0, weight=1)
    
    report = Text(topframe, width=200, height=44, background='white')
    report.grid(column=1, row=1, sticky=(W,E))
    report.insert('1.0', 
'''## Image acquisition
Open image: opens windows dialog box for selecting image to open, then opens another windows dialog box for selecting the mask (labels) file to open. If "Mass analysis" mode is checked, will open images (and corresponding masks) from "Image directory" (and "Mask directory") sequentially each time "Open image" is clicked. If there is an updated version of the mask (filename starts with "updated_"), it will be preferentially loaded. Also loads the original image file in the working directory; if subdirectory "Original" exists, will load the image file in that subdirectory with the closest name to the current image file.

Save mask: save the current mask to the "Mask directory" as a .png file with "updated_" at the beginning of the file name. This will also update the "ec_quantification.csv" file produced by ecSeg with a new column "updated #" displaying the updated ecDNA count (this overrides the "Mark inadequate" button). Also saves doublet counts and also update "ec_quantification.csv" with a new column "doublet #" displaying the doublet count. 

Mass analysis: check to enter mass analysis mode ("Open image" will open image files in "Image directory" sequentially).

Continue: if both "Mass analysis" and "Continue" are checked, "Open image" will open files in "Image directory" that do not have corresponding updated masks in "Mask directory".

Image directory: specify directory to image files for mass analysis mode.

Mask directory: specify directory to mask files for mass analysis mode.

## Show masks
Select masks (labels) to display from the mask file. The four labels from ecSeg ("background", "nuclei", "chromosome", "ecdna") are available. Additionally, user defined "doublets" and "true background" label is available as well, which are colored black. Allows for multiple selections at the same time.

Hide all: hide all masks.

Mark inadequate: labels this image as "inadequate" (i.e. inadequately labeled) in the "ec_quantification.csv" file, under column "updated #".

## Flip masks
Allows manual label adjustment of the mask file.

Flip from: select masks to be changed.

Flip to: select what to change to.

Polygon flip: click to draw and connect vertices of a polygon encirling the part of the mask image to flip. Double click to finish polygon.

Reset polygon: restart drawing polygon.

Undo: undo last change made to mask.

Reset mask: reset mask to original.

## Dot ecDNA
Allows manual identification of ecDNA.

Draw dot: draw a dot on the ecDNA mask.

Dot radius: radius of the dot, in pixels

## Identify doublets
Allows automatic and manual identification of doublet ecDNA by drawing a bounding box around the doublet.

Auto ID: auto identify doublet ecDNAs and draw a bounding box around them.

Draw box: click and drag to draw a box around a doublet. Release mouse to finish drawing box.

Undraw box: click inside a box to delete it.

Delete: delete all boxes.
''')
    report.config(state=DISABLED)
ttk.Button(about_pane, text='Help', command=helping).grid(column=1, row=3, sticky=(W,E))

def support():
    messagebox.showinfo(message='Please report bugs to Lu Yang at yanglum at stanford.edu')
ttk.Button(about_pane, text='Support', command=support).grid(column=1, row=4, sticky=(W,E))
#################### INFORMATION ######################

root.bind("<Tab>", open_file)
root.bind("<Shift_L>", show_original)
root.bind("<KeyRelease-Shift_L>", show_analyzed)
root.bind("<Control_L>", show_color_image)
root.bind("<KeyRelease-Control_L>", show_analyzed)
root.bind("<Shift_R>", save)
root.bind("<Alt_L>", mark_dms)
root.bind("<Alt_R>", select_polygon)

# add padding around each widget
for child in mainframe.winfo_children():
    child.grid_configure(padx=10, pady=10)
    
root.mainloop()


# ## Helpful information
# 
# ### Image acquisition
# Open image: opens windows dialog box for selecting image to open, then opens another windows dialog box for selecting the mask (labels) file to open. If "Mass analysis" mode is checked, will open images (and corresponding masks) from "Image directory" (and "Mask directory") sequentially each time "Open image" is clicked. If there is an updated version of the mask (filename starts with "updated_", it will be preferentially loaded. Also loads the original image file in the working directory; if subdirectory "Original" exists, will load the image file in that subdirectory with the closest name to the current image file.
# 
# Save mask: save the current mask to the "Mask directory" as a .png file with "updated_" at the beginning of the file name. This will also update the "ec_quantification.csv" file produced by ecSeg with a new column "updated #" displaying the updated ecDNA count (this overrides the "Mark inadequate" button).
# 
# Mass analysis: check to enter mass analysis mode ("Open image" will open image files in "Image directory" sequentially).
# 
# Continue: if both "Mass analysis" and "Continue" are checked, "Open image" will open files in "Image directory" that do not have corresponding updated masks in "Mask directory".
# 
# Image directory: specify directory to image files for mass analysis mode.
# 
# Mask directory: specify directory to mask files for mass analysis mode.
# 
# ### Show masks
# Select masks (labels) to display from the mask file. The four labels from ecSeg ("background", "nuclei", "chromosome", "ecdna") are available. Additionally, a user defined "true background" label is available as well, which is colored black. Allows for multiple selections at the same time.
# 
# Hide all: hide all masks.
# 
# Mark inadequate: labels this image as "inadequate" (i.e. inadequately labeled) in the "ec_quantification.csv" file, under column "updated #".
# 
# ### Toolbar
# Allows manual label adjustment of the mask file
# 
# Flip from: select masks to be changed
# 
# Flip to: select what to change to
# 
# Polygon flip: draw vertices of a polygon encirling the part of the mask image to flip. Double click to finish polygon.
# 
# Reset polygon: restart drawing polygon
# 
# Undo: undo last change made to mask
# 
# Reset mask: reset mask to original

# In[ ]:




