#!/usr/bin/env python
# coding: utf-8

# # metaSeg GUI

version_no = "7"

# ### change log
# v7: QoL changes: hotkeys (tab to open image, enter to save mask), resize window upon start. Continue checkbox, if checked, now shows images without updated masks. Adjust current image and mask displays. Remove pixel pane (pixel count display)
# 
# v6: add button for marking image as inadequate (write "inadequate" to ec_quantification.csv)
# 
# v5: add true_background mask and add option to see original image (both dapi and stains)
# 
# v4: update ec_quantification csv file with updated counts from findContours when mask is saved
# 
# v3: count ecDNA using ecSeg generated mask and findContours, which updates as mask is updated
# 
# v2: reads the ec_quantification.csv file generated by ecseg and displays # of ec for the opened image
# 
# v1: saves mask with "updated_" prefix and when auto loading masks, looks for "updated_" masks first

from tkinter import *
from tkinter import ttk, filedialog
from tkinter import messagebox

from PIL import ImageGrab, Image, ImageTk

import yaml
import os
import pathlib # for making temp directory
import glob # for temp mask files
import datetime # for naming temp mask files

import difflib # for get close matches
                
import numpy as np
from skimage import draw
from skimage import io
from skimage.color import gray2rgb

import pandas as pd
import cv2


# In[14]:


def filename_counter(counter):
    if counter < 10:
        fname = "000"+str(counter)
    elif counter < 100:
        fname = "00"+str(counter)
    elif counter < 1000:
        fname = "0"+str(counter)
    else:
        fname = str(counter)
    return fname


# In[15]:


def update_temp(*args): # this is for drawing lines for polygons (temporary)
    temp_overlay = image_dict['image_overlay'].copy()
    temp_overlay[mask_dict['temp_mask']] = [0,0,0]
    image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(temp_overlay))
    canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")

# funtion to be called when "Polygon select" button is clicked
def select_polygon(*args):    
    canvas.bind("<ButtonPress-1>", savecoords)
    canvas.bind("<Double-Button-1>", mask_set) # double clicking ends coords collection and calculates

def savecoords(event):
    
    event2canvas = lambda e, c: (c.canvasx(e.x), c.canvasy(e.y)) # converts event (window) coordinates to image coordinates
    cx, cy = event2canvas(event, canvas)
    
    # prevent out of bounds event
    if cx < 0:
        cx = 0
    if cx >= image_dict['image0'].shape[1]:
        cx = image_dict['image0'].shape[1]-1
    if cy < 0:
        cy = 0
    if cy >= image_dict['image0'].shape[0]:
        cy = image_dict['image0'].shape[0]-1
        
    xcoor.append(int(cx))
    ycoor.append(int(cy))

    if len(xcoor)>1:
        rr, cc = draw.line(ycoor[-2], xcoor[-2], ycoor[-1], xcoor[-1])
        mask_dict['temp_mask'][rr, cc] = True
        update_temp()

def mask_set(event): 
    event2canvas = lambda e, c: (c.canvasx(e.x), c.canvasy(e.y)) # converts event (window) coordinates to image coordinates
    cx, cy = event2canvas(event, canvas)
    xcoor.append(cx)
    ycoor.append(cy)
    r = np.array(ycoor)
    c = np.array(xcoor)
    rr, cc = draw.polygon(r, c)
    
    # reset
    xcoor.clear()
    ycoor.clear()
    mask_dict['temp_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
    
    flip_masks(switches['flip_from'], switches['flip_to'], rr, cc)

def flip_masks(flip_from, flip_to, rr, cc):
    '''
    flip masks from/to background, fat, bone, cartilage, blood, cells
    flip_from is a list of strings
    flip_to is a string
    '''
    for i in flip_from:
        if i == 0:
            mask_dict['back_mask'][rr,cc] = False
        elif i == 1:
            mask_dict['nuclei_mask'][rr,cc] = False
        elif i == 2:
            mask_dict['chromo_mask'][rr,cc] = False
        elif i == 3:
            mask_dict['ecdna_mask'][rr,cc] = False
        elif i == 4:
            mask_dict['trueba_mask'][rr,cc] = False

    temp_filter = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), True)
    temp_filter[mask_dict['back_mask']] = False
    temp_filter[mask_dict['nuclei_mask']] = False
    temp_filter[mask_dict['chromo_mask']] = False
    temp_filter[mask_dict['ecdna_mask']] = False
    temp_filter[mask_dict['trueba_mask']] = False
    
    for i in flip_to:
        if i == 0:
            mask_dict['back_mask'][temp_filter] = True
        elif i == 1:
            mask_dict['nuclei_mask'][temp_filter] = True
        elif i == 2:
            mask_dict['chromo_mask'][temp_filter] = True
        elif i == 3:
            mask_dict['ecdna_mask'][temp_filter] = True
        elif i == 4:
            mask_dict['trueba_mask'][temp_filter] = True

    update_image(update_pixels=True, save_temp=True)
    
# function to be called when "reset polygon" button is clicked
def reset_polygon(*args):
    xcoor.clear()
    ycoor.clear()
    mask_dict['temp_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
    update_temp()


# In[16]:


def update_image(update_pixels=False, save_temp=False):
    if 'display_masks' not in switches:
        image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(image_dict['image0']))
        canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")
    else:
        image_dict['image_overlay'] = image_dict['image0'].copy()
        

        for i in switches['display_masks']:
            if i == 0:
                image_dict['image_overlay'][mask_dict['back_mask']] = [56, 108, 176]
            elif i == 1:
                image_dict['image_overlay'][mask_dict['nuclei_mask']] = [255, 255, 153]
            elif i == 2:
                image_dict['image_overlay'][mask_dict['chromo_mask']] = [127, 201, 127]
            elif i == 3:
                image_dict['image_overlay'][mask_dict['ecdna_mask']] = [240, 2, 127]
            elif i == 4:
                image_dict['image_overlay'][mask_dict['trueba_mask']] = [0, 0, 0]

        image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(image_dict['image_overlay']))
        canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")
    
    if update_pixels==True: # this should be called when masks are actually manipulated 
        # Set pixels
        back_pixels.set(mask_dict['back_mask'].sum())
        nuclei_pixels.set(mask_dict['nuclei_mask'].sum())
        chromo_pixels.set(mask_dict['chromo_mask'].sum())
        ecdna_pixels.set(mask_dict['ecdna_mask'].sum())
        trueba_pixels.set(mask_dict['trueba_mask'].sum())

        unmasked_pixels.set(image_pixels.get() - (back_pixels.get()+
                                                  nuclei_pixels.get()+
                                                  chromo_pixels.get()+
                                                  ecdna_pixels.get()+
                                                  trueba_pixels.get()))
        
        # v3 update ecDNA counts using findContours
        cnts = cv2.findContours(mask_dict['ecdna_mask'].astype(np.uint8), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)[-2]
        updated_count.set(len(cnts))
    
    if save_temp==True: # called when masks are created, loaded, or manipulated
        pathlib.Path('./temp').mkdir(parents=True, exist_ok=True)

        temp_filter = np.zeros((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), dtype=np.uint8)
        temp_filter = gray2rgb(temp_filter)
        temp_filter[mask_dict['back_mask']] = [56, 108, 176]
        temp_filter[mask_dict['nuclei_mask']] = [255, 255, 153]
        temp_filter[mask_dict['chromo_mask']] = [127, 201, 127]
        temp_filter[mask_dict['ecdna_mask']] = [240, 2, 127]
        temp_filter[mask_dict['trueba_mask']] = [0, 0, 0]

        io.imsave('./temp/temp_mask'+datetime.datetime.now().strftime('%Y%m%d%H%M%S')+'.png',
                  temp_filter, check_contrast=False)
    
def undo_manip(*args):
    try:
        latest_temp = get_latest_file('./temp/temp_mask*')
        os.remove(latest_temp)
        latest_temp = get_latest_file('./temp/temp_mask*')
        temp_filter = io.imread(latest_temp)
        divide_masks(temp_filter)
        update_image(update_pixels=True)
    except:
        messagebox.showinfo(message='Nothing to undo')

def get_latest_file(directory):
    temp_mask_list = glob.glob(directory)
    latest_temp = max(temp_mask_list, key=os.path.getctime)
    return latest_temp


# In[17]:


def divide_masks(mask):
    reset(reset_masks=True)
    mask_dict['back_mask'][np.where(np.all(mask==[56, 108, 176], axis=-1))] = True
    mask_dict['nuclei_mask'][np.where(np.all(mask==[255, 255, 153], axis=-1))] = True
    mask_dict['chromo_mask'][np.where(np.all(mask==[127, 201, 127], axis=-1))] = True
    mask_dict['ecdna_mask'][np.where(np.all(mask==[240, 2, 127], axis=-1))] = True
    mask_dict['trueba_mask'][np.where(np.all(mask==[0, 0, 0], axis=-1))] = True

def reset(reset_image=False, reset_masks=False, reset_pixels=False): # does not reset ecseg mask
    if reset_image==True:
        # reset image
        image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(image_dict['image0']))
        canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")
        image_dict['image_overlay'] = image_dict['image0'].copy()
    
    if reset_masks==True:
        # reset masks    
        mask_dict['back_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
        mask_dict['nuclei_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
        mask_dict['chromo_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
        mask_dict['ecdna_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
        mask_dict['trueba_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
        mask_dict['temp_mask'] = np.full((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), False)
    
    if reset_pixels==True:
        # reset pixels
        back_pixels.set(0)
        nuclei_pixels.set(0)
        chromo_pixels.set(0)
        ecdna_pixels.set(0)

        unmasked_pixels.set(image_pixels.get())
    
def show_original(*args):  
    temp_overlay = image_dict['image0'].copy()
            
    temp_overlay[mask_dict['temp_mask']] = [0,0,0]
    image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(temp_overlay))
    canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")

def show_analyzed(*args):
    image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(image_dict['image_overlay']))
    canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")
    
def show_color_image(*args):
    image_dict['image1'] = ImageTk.PhotoImage(image = Image.fromarray(image_dict['color_image']))
    canvas.create_image(0,0,image=image_dict['image1'],anchor="nw")


# In[61]:


def populate_image_files(*args):
    all_files.clear()
    for file in os.listdir(image_path.get()):
        if file.endswith(".PNG") or file.endswith(".png") or file.endswith(".TIF") or file.endswith(".tif"):
            if continue_state.get() == 1:
                if 'updated_'+file not in os.listdir(mask_path.get()): #v7
                    all_files.append(file)
            elif continue_state.get() == 0:
                all_files.append(file)

def clear_temp_folder(*args):
    if pathlib.Path('/temp').is_dir():
        files = glob.glob('/temp/*')
        for f in files:
            os.remove(f)
    
def open_file(*args): 
    try:
        if mass_state.get() == 0:
            File = filedialog.askopenfilename(parent=root, initialdir=inpath,
                                    title='Select image file to open')#, filetypes=[("image", ".png", ".tif")])
            #print("opening %s" % File)
        elif mass_state.get() == 1:
            populate_image_files()
            File = os.path.join(image_path.get(), all_files[file_number.get()])
            file_number.set(file_number.get()+1)
            if file_number.get() == len(all_files):
                messagebox.showinfo(message='This is the last image')
        
        clear_temp_folder()
        imgfile.set(File.split('/')[-1])
        image_dict['image0'] = io.imread(File) # must be .png or .tif
        
        if os.path.isdir('original'): #v7
            color_image = difflib.get_close_matches(imgfile.get(), os.listdir(inpath+'/original'), n=1, cutoff=0)[0]
            image_dict['color_image'] = io.imread(inpath+'/original/'+color_image)
        else: #v7
            image_dict['color_image'] = io.imread(inpath+'/'+imgfile.get())
        
        if len(np.shape(image_dict['image0'])) == 3:
            image_dict['image0'] = image_dict['image0'][:, :, :3] # make sure the image only has 3 color channels (no alpha)
        else:
            image_dict['image0'] = gray2rgb(image_dict['image0'])
        image_pixels.set(int(image_dict['image0'].size/3))

        reset(reset_image=True, reset_masks=True, reset_pixels=True)
        mask_dict.pop('ecseg_mask', None)
        
        canvas.config(scrollregion=canvas.bbox(ALL), width=image_dict['image1'].width(), height=image_dict['image1'].height()) # initiates window with adjusted size to image_dict['image1']
        
        load_masks()
    except:
        print('open_file error')


# In[62]:


def save(*args):
    if unmasked_pixels.get()!=0:
        proceed = messagebox.askyesno(message='There are unmasked pixels! Proceed?',
                           icon='question', title='Save mask')
        if proceed == True:
            save_masks()
            messagebox.showinfo('Mask saved as:', maskfile.get())
    elif unmasked_pixels.get()<0:
        proceed = messagebox.askyesno(message='There are double-masked pixels! Proceed?',
                           icon='question', title='Save mask')
        if proceed == True:
            save_masks()
            messagebox.showinfo('Mask saved as:', maskfile.get())
    else:
        save_masks()
        messagebox.showinfo('Mask saved as:', maskfile.get())

def save_masks(*args): # called on by function save() (defined in tkinter)
    temp_filter = np.zeros((image_dict['image0'].shape[0], image_dict['image0'].shape[1]), dtype=np.uint8)
    temp_filter = gray2rgb(temp_filter)
    
    temp_filter[mask_dict['back_mask']] = [56, 108, 176]
    temp_filter[mask_dict['nuclei_mask']] = [255, 255, 153]
    temp_filter[mask_dict['chromo_mask']] = [127, 201, 127]
    temp_filter[mask_dict['ecdna_mask']] = [240, 2, 127]
    temp_filter[mask_dict['trueba_mask']] = [0, 0, 0]

    # background = [56, 108, 176]
    # nuclei = [255, 255, 153]
    # chromosome = [127, 201, 127]
    # ecdna = [240, 2, 127]

    try:
        if mass_state.get() == 0:
            File = filedialog.asksaveasfilename(parent=root, initialdir=inpath,
                                                title='Save as', filetypes=[("image", ".png")])
            maskfile.set(File.split('/')[-1])
        elif mass_state.get() == 1:
            maskfile.set(mask_path.get() + 'updated_' + imgfile.get()[:-4] + '.png')
        io.imsave(maskfile.get(), temp_filter, check_contrast=False)
    except:
        print('save_masks error')
    
    # v4 update and save ec_quantification.csv file
    image_dict['ec_counts'].loc[image_dict['ec_counts']['image name']==imgfile.get(), 'updated #']=updated_count.get()    
    image_dict['ec_counts'].to_csv(inpath+'/ec_quantification.csv', index=False)    
    
    # clear temp directory
    clear_temp_folder()

# v6
def mark_inadequate(*args):
    image_dict['ec_counts'].loc[image_dict['ec_counts']['image name']==imgfile.get(), 'updated #']='inadequate'   
    image_dict['ec_counts'].to_csv(inpath+'/ec_quantification.csv', index=False)  
    
def load_masks(*args):
    if 'image0' not in image_dict:
        messagebox.showinfo(message='Open an image file first')
        return
    try:
        if mass_state.get() == 0:
            File = filedialog.askopenfilename(parent=root, initialdir=inpath,
                                        title='Select mask (labels) file to open', filetypes=[("image", ".png")])
            maskfile.set(File.split('/')[-1])
            mask_dict['ecseg_mask'] = io.imread(File)
            mask_dict['ecseg_mask'] = mask_dict['ecseg_mask'][:,:,:3]

        elif mass_state.get() == 1:
            updatedFile = mask_path.get() + 'updated_' + imgfile.get()[:-4] + '.png'
            File = mask_path.get() + imgfile.get()[:-4] + '.png'
            if os.path.exists(updatedFile):
                maskfile.set(updatedFile.split('/')[-1])
                mask_dict['ecseg_mask'] = io.imread(updatedFile)
            else:
                maskfile.set(File.split('/')[-1])
                mask_dict['ecseg_mask'] = io.imread(File)
            mask_dict['ecseg_mask'] = mask_dict['ecseg_mask'][:,:,:3]
    except:
        print('load_masks error')  
    
    divide_masks(mask_dict['ecseg_mask'])
    update_image(update_pixels=True, save_temp=True)
    
    # v2 load ecSeg counts
    image_dict['ec_counts'] = pd.read_csv(inpath+'/ec_quantification.csv')
    ecseg_count.set(int(image_dict['ec_counts'].loc[image_dict['ec_counts']['image name']==imgfile.get(), '# of ec']))


# In[63]:


###### intialize ######
config = open("config.yaml")
var = yaml.load(config, Loader=yaml.FullLoader)['metaseg']
inpath = var['inpath']

LABELS = ['background','nuclei', 'chromosome', 'ecdna', 'true background']

# background = [56, 108, 176]
# nuclei = [255, 255, 153]
# chromosome = [127, 201, 127]
# ecdna = [240, 2, 127]

all_files = []

# for polygon mask flip tool
ycoor = []
xcoor = []

switches = {}
# flip_from
# flip_to
# display_masks

image_dict = {}
# image0 is the original, never manipulate once open
# image_overlay is manipulated with overlaid masks instead
# image1

mask_dict = {}
# ecseg_mask is the original, never manipulate once created or loaded. Resets only when new image is opened
# individual masks are edited with tools: back_mask, nuclei_mask, chromo_mask, ecdna_mask, blood_mask, marrow_mask, temp_mask

# v4 duplicate # of ec column in ec_quantification.csv
ecseg_df = pd.read_csv(inpath+'/ec_quantification.csv')
if 'updated #' not in ecseg_df.columns:
    ecseg_df['updated #'] = ecseg_df['# of ec']
ecseg_df.to_csv(inpath+'/ec_quantification.csv', index=False)
###### initialize ######


# In[73]:


# Tkinter GUI
root = Tk()
root.title('metaSeg GUI')
#root.geometry('280x400-1+3')

mainframe = ttk.Panedwindow(root, orient=HORIZONTAL) # canvas is preventing horizontal placement of canvas child
mainframe.pack(fill=BOTH, expand=1)
mainframe.grid_columnconfigure(0, weight=1) # expand frame to fill extra space if window is resized
mainframe.grid_rowconfigure(0, weight=1)

# image frame
image_frame = ttk.Frame(mainframe) # doesn't matter what this widget is (Label, Frame, etc) because canvas takes over
image_frame.pack(fill=BOTH, expand=1)
image_frame.grid_columnconfigure(0, weight=1) # expand frame to fill extra space if window is resized
image_frame.grid_rowconfigure(0, weight=1)
mainframe.add(image_frame)

xscroll = Scrollbar(image_frame, orient=HORIZONTAL)
xscroll.grid(row=1, column=0, sticky=E+W)
yscroll = Scrollbar(image_frame)
yscroll.grid(row=0, column=1, sticky=N+S)
canvas = Canvas(image_frame, bd=0, xscrollcommand=xscroll.set, yscrollcommand=yscroll.set)
canvas.grid(row=0, column=0, sticky=N+S+E+W)
xscroll.config(command=canvas.xview)
yscroll.config(command=canvas.yview)
image_frame.pack(fill=BOTH,expand=1)

# paned windows for widgets (inside mainframe)
paned = ttk.Panedwindow(mainframe, orient=HORIZONTAL)
paned.pack(fill=BOTH, expand=1)
mainframe.add(paned)

subpaned2 = ttk.Panedwindow(paned, orient=VERTICAL) #v7
paned.add(subpaned2) #v7
current_pane = ttk.Labelframe(subpaned2, text='Current image', height=85, width=160) #v7
current_pane.grid_propagate(False) #v7
subpaned2.add(current_pane) #v7
currmask_pane = ttk.Labelframe(subpaned2, text='Current mask') #v7
subpaned2.add(currmask_pane) # v7

subpaned1 = ttk.Panedwindow(paned, orient=VERTICAL)
paned.add(subpaned1)
acq_pane = ttk.Labelframe(subpaned1, text='Image acquisition')
subpaned1.add(acq_pane)
count_pane = ttk.Labelframe(subpaned1, text='ecDNA count') # v3
subpaned1.add(count_pane) # v3 # v7

subpaned3 = ttk.Panedwindow(paned, orient=VERTICAL)
paned.add(subpaned3)
masks_pane = ttk.Labelframe(subpaned3, text='Show masks')
subpaned3.add(masks_pane)

subpaned4 = ttk.Panedwindow(paned, orient=VERTICAL)
paned.add(subpaned4)
toolbar_pane = ttk.Labelframe(subpaned4, text='Toolbar')
subpaned4.add(toolbar_pane)

#subpaned5 = ttk.Panedwindow(paned, orient=VERTICAL)
#paned.add(subpaned5)
#pixel_pane = ttk.Labelframe(subpaned5, text='Pixel count') # v2
#subpaned5.add(pixel_pane) # v2

subpaned6 = ttk.Panedwindow(paned, orient=VERTICAL)
paned.add(subpaned6)
about_pane = ttk.Labelframe(subpaned6, text='Info')
subpaned6.add(about_pane)

#################### IMAGE ACQUISITION ######################
# Open image
ttk.Button(acq_pane, text='Open image', command=open_file).grid(column=1, row=1, sticky=(W,E))

# Save masks button
maskfile = StringVar()
ttk.Button(acq_pane, text='Save mask', command=save).grid(column=2, row=1, sticky=(W,E))

# Load masks button
#ttk.Button(acq_pane, text='Load mask', command=load_masks).grid(column=2, row=2, sticky=(W,E))

# Mass analysis checkbox
file_number = IntVar()
file_number.set(0)
mass_state = IntVar(value=1)
ttk.Checkbutton(acq_pane, text='Mass analysis', variable=mass_state).grid(column=1, row=3, sticky=(W,E))
# if checked, presumes there is an images subdir and masks subdir. Open will open images in order from images/, save will save masks to masks/

# Continue from where left off checkbox
continue_state = IntVar()
ttk.Checkbutton(acq_pane, text='Continue', command=populate_image_files, 
                variable=continue_state).grid(column=2, row=3, sticky=(W,E))

# Image directory
image_path = StringVar()
ttk.Label(acq_pane, text='Image directory:').grid(column=1, row=4, sticky=(W,E))
id_entry = ttk.Entry(acq_pane, textvariable=image_path, width=15)
id_entry.grid(column=2, row=4, sticky=W)
id_entry.insert(0, inpath+'/dapi/')

# Mask directory
mask_path = StringVar()
ttk.Label(acq_pane, text='Mask directory:').grid(column=1, row=5, sticky=(W,E))
md_entry = ttk.Entry(acq_pane, textvariable=mask_path, width=15)
md_entry.grid(column=2, row=5, sticky=W)
md_entry.insert(0, inpath+'/labels/')

# v7
imgfile = StringVar()
ttk.Label(current_pane, textvariable=imgfile, wraplength=150).grid(column=1, row=1, sticky=(W,E))

ttk.Label(currmask_pane, textvariable=maskfile, wraplength=150).grid(column=1, row=1, sticky=(W,E))
#################### IMAGE ACQUISITION ######################

######################### REPORT ######################### 
# Show masks
def update_display(*args):
    switches['display_masks'] = show_masks.curselection()
    update_image()
choicesvar = StringVar(value=LABELS)
show_masks = Listbox(masks_pane, listvariable=choicesvar, activestyle='none',
                     selectmode='extended', exportselection=0, width=15, height=5)
show_masks.select_set(3)
show_masks.grid(column=1, row=1, sticky=(W,E))
show_masks.bind("<<ListboxSelect>>", update_display)

def hide_all(*args):
    show_masks.selection_clear(0, END)
    switches.pop('display_masks', None) # really should be an empty tuple, but doesn't matter
    update_image()
ttk.Button(masks_pane, text='Hide all', command=hide_all).grid(column=1, row=2, sticky=(W,E))

# v6
ttk.Button(masks_pane, text='Mark inadequate', command=mark_inadequate).grid(column=1, row=3, sticky=(W,E))
######################### REPORT #########################

#################### TOOLBAR ######################
def update_flip(*args):
    switches['flip_from'] = from_.curselection()
    switches['flip_to'] = to_.curselection()
choicesvar = StringVar(value=LABELS)

ttk.Label(toolbar_pane, text='Flip from:').grid(column=1, row=1, sticky=(W,E))
from_ = Listbox(toolbar_pane, listvariable=choicesvar, selectmode='extended', activestyle='none',
                exportselection=0, width=15, height=5)
from_.grid(column=1, row=2, sticky=(W,E))
from_.bind("<<ListboxSelect>>", update_flip)

ttk.Label(toolbar_pane, text='Flip to:').grid(column=2, row=1, sticky=(W,E))
to_ = Listbox(toolbar_pane, listvariable=choicesvar, selectmode='browse', activestyle='none',
              exportselection=0, width=15, height=5)
to_.grid(column=2, row=2, sticky=(W,E))
to_.bind("<<ListboxSelect>>", update_flip)

ttk.Button(toolbar_pane, text='Polygon flip', command=select_polygon).grid(column=1, row=3, sticky=(W,E))
ttk.Button(toolbar_pane, text='Reset polygon', command=reset_polygon).grid(column=2, row=3, sticky=(W,E))
ttk.Button(toolbar_pane, text='Undo', command=undo_manip).grid(column=1, row=4, sticky=(W,E))
ttk.Button(toolbar_pane, text='Reset mask', command=reset).grid(column=2, row=4, sticky=(W,E))
#################### TOOLBAR ######################

############################ PIXELS ###########################
image_pixels = IntVar()
#ttk.Label(pixel_pane, text='Image:').grid(column=1, row=1, sticky=E)
#ttk.Label(pixel_pane, textvariable=image_pixels).grid(column=2, row=1, sticky=W)

ecdna_pixels = IntVar()
#ttk.Label(pixel_pane, text='ecDNA:').grid(column=1, row=2, sticky=E)
#ttk.Label(pixel_pane, textvariable=ecdna_pixels).grid(column=2, row=2, sticky=W)

chromo_pixels = IntVar()
#ttk.Label(pixel_pane, text='Chromosome:').grid(column=1, row=3, sticky=E)
#ttk.Label(pixel_pane, textvariable=chromo_pixels).grid(column=2, row=3, sticky=W)

nuclei_pixels = IntVar()
#ttk.Label(pixel_pane, text='Nuclei:').grid(column=1, row=4, sticky=E)
#ttk.Label(pixel_pane, textvariable=nuclei_pixels).grid(column=2, row=4, sticky=W)

back_pixels = IntVar()
#ttk.Label(pixel_pane, text='Background:').grid(column=1, row=5, sticky=E)
#ttk.Label(pixel_pane, textvariable=back_pixels).grid(column=2, row=5, sticky=W)

trueba_pixels = IntVar()
#ttk.Label(pixel_pane, text='True background:').grid(column=1, row=6, sticky=E)
#ttk.Label(pixel_pane, textvariable=trueba_pixels).grid(column=2, row=6, sticky=W)

unmasked_pixels = IntVar()
#ttk.Label(pixel_pane, text='Unmasked:').grid(column=1, row=6, sticky=E)
#ttk.Label(pixel_pane, textvariable=unmasked_pixels).grid(column=2, row=6, sticky=W)

# v2
ecseg_count = IntVar()
ttk.Label(count_pane, text='ecSeg (original):').grid(column=1, row=1, sticky=E)
ttk.Label(count_pane, textvariable=ecseg_count).grid(column=2, row=1, sticky=W)

# v3
updated_count = IntVar()
ttk.Label(count_pane, text='metaseg GUI (updated):').grid(column=1, row=2, sticky=E)
ttk.Label(count_pane, textvariable=updated_count).grid(column=2, row=2, sticky=W)
############################ PIXELS ###########################

#################### INFORMATION ######################
# About button
def about():
    messagebox.showinfo(
        message='GUI for evaluating and editing labels generated by ecSeg. Version '+version_no
    )
ttk.Button(about_pane, text='About', command=about).grid(column=1, row=1, sticky=(W,E))

def hot_keys(*args):
    new_window = Toplevel(root)
    new_window.title('Hot Keys')
    new_window.resizable(False, False)
    topframe = ttk.Panedwindow(new_window, orient=VERTICAL)
    topframe.pack(fill=BOTH, expand=1)
    topframe.grid_columnconfigure(0, weight=1) # expand frame to fill extra space if window is resized
    topframe.grid_rowconfigure(0, weight=1)
    
    report = Text(topframe, width=50, height=6, background='white')
    report.grid(column=1, row=1, sticky=(W,E))
    report.insert('1.0',
'''tab: open image
hold left shift: display dapi image
hold control: display original image
right shift: save mask''')
    report.config(state=DISABLED)
ttk.Button(about_pane, text='Hot keys', command=hot_keys).grid(column=1, row=2, sticky=(W,E))

def helping():
    new_window = Toplevel(root)
    new_window.title('Help')
    new_window.resizable(False, False)
    topframe = ttk.Panedwindow(new_window, orient=VERTICAL)
    topframe.pack(fill=BOTH, expand=1)
    topframe.grid_columnconfigure(0, weight=1) # expand frame to fill extra space if window is resized
    topframe.grid_rowconfigure(0, weight=1)
    
    report = Text(topframe, width=50, height=6, background='white')
    report.grid(column=1, row=1, sticky=(W,E))
    report.insert('1.0', 'Help')
    report.config(state=DISABLED)
ttk.Button(about_pane, text='Help', command=helping).grid(column=1, row=3, sticky=(W,E))

def support():
    messagebox.showinfo(message='Please report bugs to Lu Yang at yanglum at stanford.edu')
ttk.Button(about_pane, text='Support', command=support).grid(column=1, row=4, sticky=(W,E))
#################### INFORMATION ######################

root.bind("<Tab>", open_file)
root.bind("<Shift_L>", show_original)
root.bind("<KeyRelease-Shift_L>", show_analyzed)
root.bind("<Control_L>", show_color_image)
root.bind("<KeyRelease-Control_L>", show_analyzed)
root.bind("<Shift_R>", save)

# add padding around each widget
for child in mainframe.winfo_children():
    child.grid_configure(padx=10, pady=10)
    
root.mainloop()


# ## Helpful information
# 
# ### Image acquisition
# Open image: opens windows dialog box for selecting image to open, then opens another windows dialog box for selecting the mask (labels) file to open. If "Mass analysis" mode is checked, will open images (and corresponding masks) from "Image directory" (and "Mask directory") sequentially each time "Open image" is clicked. If there is an updated version of the mask (filename starts with "updated_", it will be preferentially loaded. Also loads the original image file in the working directory; if subdirectory "Original" exists, will load the image file in that subdirectory with the closest name to the current image file.
# 
# Save mask: save the current mask to the "Mask directory" as a .png file with "updated_" at the beginning of the file name. This will also update the "ec_quantification.csv" file produced by ecSeg with a new column "updated #" displaying the updated ecDNA count (this overrides the "Mark inadequate" button).
# 
# Mass analysis: check to enter mass analysis mode ("Open image" will open image files in "Image directory" sequentially).
# 
# Continue: if both "Mass analysis" and "Continue" are checked, "Open image" will open files in "Image directory" that do not have corresponding updated masks in "Mask directory".
# 
# Image directory: specify directory to image files for mass analysis mode.
# 
# Mask directory: specify directory to mask files for mass analysis mode.
# 
# ### Show masks
# Select masks (labels) to display from the mask file. The four labels from ecSeg ("background", "nuclei", "chromosome", "ecdna") are available. Additionally, a user defined "true background" label is available as well, which is colored black. Allows for multiple selections at the same time.
# 
# Hide all: hide all masks.
# 
# Mark inadequate: labels this image as "inadequate" (i.e. inadequately labeled) in the "ec_quantification.csv" file, under column "updated #".
# 
# ### Toolbar
# Allows manual label adjustment of the mask file
# 
# Flip from: select masks to be changed
# 
# Flip to: select what to change to
# 
# Polygon flip: draw vertices of a polygon encirling the part of the mask image to flip. Double click to finish polygon.
# 
# Reset polygon: restart drawing polygon
# 
# Undo: undo last change made to mask
# 
# Reset mask: reset mask to original




